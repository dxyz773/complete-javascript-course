'use strict';

///////////////////////////////////////
// Modal window

const modal = document.querySelector('.modal');
const overlay = document.querySelector('.overlay');
const btnCloseModal = document.querySelector('.btn--close-modal');
const btnsOpenModal = document.querySelectorAll('.btn--show-modal');
const btnScrollTo = document.querySelector('.btn--scroll-to');
const section1 = document.getElementById('section--1');

const openModal = function (e) {
  e.preventDefault();
  modal.classList.remove('hidden');
  overlay.classList.remove('hidden');
};

const closeModal = function () {
  modal.classList.add('hidden');
  overlay.classList.add('hidden');
};

btnsOpenModal.forEach(curr => curr.addEventListener('click', openModal));

btnCloseModal.addEventListener('click', closeModal);
overlay.addEventListener('click', closeModal);

document.addEventListener('keydown', function (e) {
  if (e.key === 'Escape' && !modal.classList.contains('hidden')) {
    closeModal();
  }
});

// To see the viewport height and width
// console.log(
//   document.documentElement.clientHeight,
//   document.documentElement.clientWidth
// );

//Implements smooth scrolling from button clicked to section1

btnScrollTo.addEventListener('click', function () {
  section1.scrollIntoView({ behavior: 'smooth' });
});

// --------------- Types of Events and Event Handlers ------------------- //

// An event is a signal that is generated by a certain DOM node that something has happened, and we can use event listeners to listen to these events so that we can handle them if we so choose too.

// Regardless of if we listen and handle them or not. they occur

const h1 = document.querySelector('h1');

// mouseenter event fires whenever a mouse enters a certain element
// h1.addEventListener('mouseenter', function (e) {
//   alert('You are reading the heading! ');
// });

// OLD SCHOOL way - Using the "on event" property directly on the element as another way of attaching an event listener to an element
//Ex:

// h1.onmouseenter = function (e) {
//   alert('You are touching the h1');
// };

//Adding and removing an event listener in the same function. This will alert once and then that event listener is moved within the same function. This is used to only listen for an event Once

// const h1Hover = function (e) {
//   alert('You are hoving the H1');

//   h1.removeEventListener('mouseenter', h1Hover);
// };

// h1.addEventListener('mouseenter', h1Hover);

// ---------- Event Propogation: Bubbling and Capturing --------------- //

//JavaScript events have a "capturing" phase and a "bubbling" phase

//Whenever an event happens, the event is actually generated NOT at the site of the event itself but at the ROOT of the document, the top of the DOM tree

//The capturing phase is when the event travels all the way down from the Root to the target element that elicited the generated event. As it travels down the tree, it will pass through every single parent element of the target element

//As soon as the event reaches the target, the Target phase begins where events can be handled right at the target

//Event listeners are attached to the element waiting for an event to arrive and will run the callback function

//Once the event reaches the target, the "Bubbling phase" begins and the event bubbles back up through all of it's parent elements back to the document root

//As an event bubbles through it's parent elements on the way back up to the root, is will be as if that event happened in that parent element. This is all called event propogating

// ----------------------- DOM Life Cycle ---------------------------- //

// window.addEventListener('beforeunload', function (e) {
//   e.preventDefault();
//   console.log(e);
//   e.returnValue = '';
// });

//This will cause a popup window to appear right before unloading of the page asking if the user really wants to leave. She be used only sparingly for situations where a user's content could be lost like closing a tab in the middle of writing a blog post

// ---------------- The Intersection Observer API -------------------- //

// The Intersection Observer API - allows our code to observer changes to the way a certain target element intersects another element or the way it intersects the viewport

// new IntersectionObserver(callback, optionsObject)

// Callback Function: This callback function will be called each time that the observed/target element is intersecting the root element at the threshold that we defined. No matter if I scroll up or down. The function is called with TWO arguments: (entries, observerObject). Entries is an array of the thresholds
const obsCallback = function (entries, observer) {
  entries.forEach(entry => console.log(entry));
};

//Options Object:
//Root property in options object. Root defines the the element that target is intersecting. If root is set to null, then the element that will observe our target element intersecting the entire viewport

// threshold property - The percentage of intersection at which the observer callback will be called. It is between 0 and 1.
const obsOptions = { root: null, threshold: 0.1 };

//Creates a new intersection observer
const observer = new IntersectionObserver(obsCallback, obsOptions);

//Calling the observe method on the observer and passsing in our target element
observer.observe(section1);
